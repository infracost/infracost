<conventions>
    <purpose>
        The purpose of this document is to describe the required casing paradigm needed for this
        project. We require camelCase for indexes to particular get operations.
    </purpose>
    <instructions>
        <instruction>
        You are tasked with converting Terraform-based resource files to Pulumi-compatible resource files for the Infracost project. Follow these instructions carefully to ensure accurate and consistent transformation across AWS, Google, and Azure cloud providers.

        First, you will be working with the following repositories and schemas:

        Original Terraform-based repository:
            <original_repo>https://github.com/infracost/infracost/tree/master/internal/providers/terraform/</original_repo>

        Transformed Pulumi-based repository:
            <transformed_repo>https://github.com/rshade/infracost/tree/feat/pulumi/internal/resources/</transformed_repo>

        Pulumi schema URLs:
            <pulumi_aws_schema>https://github.com/pulumi/pulumi-aws/blob/master/provider/cmd/pulumi-resource-aws/schema.json</pulumi_aws_schema>
            <pulumi_google_schema>https://github.com/pulumi/pulumi-gcp/blob/master/provider/cmd/pulumi-resource-gcp/schema.json</pulumi_google_schema>
            <pulumi_azure_schema>https://github.com/pulumi/pulumi-gcp/blob/master/provider/cmd/pulumi-resource-gcp/schema.json</pulumi_azure_schema>

        For each file in the original repository's AWS, Google, and Azure folders, perform the following steps:

        1. Check if a corresponding file exists in the transformed repository's respective folder (aws, google, or azure).

        2. If the file exists in the transformed repository:
        a. Replace "CoreRFunc" with "RFunc" in the RegistryItem function definition.
        b. Update the RegistryItem.Name to the appropriate Pulumi identifier by referring to the corresponding Pulumi schema (AWS, Google, or Azure).
        c. Modify function signatures in resource creation functions to include an additional "u *schema.UsageData" parameter.
        d. Change return types from "schema.CoreResource" to "*schema.Resource".
        e. Add calls to "PopulateUsage(u)" and "BuildResource()" before returning in each resource creation function.

        3. If the file does not exist in the transformed repository:
        a. Create a new file in the respective folder (aws, google, or azure) of the transformed repository.
        b. Base the new file on the corresponding file from the original repository.
        c. Apply all the transformations listed in step 2 to this new file.

        4. Ensure consistent naming conventions and usage functionality across all cloud providers.

        5. For each file processed, provide a brief summary of the changes made or the creation of a new file. Include the following information:
        - File name
        - Whether it was transformed or newly created
        - Key changes made (e.g., function signature updates, name mapping changes)

        Present your output in the following format:

            <file_summary>
                <file_name>[Name of the file]</file_name>
                <status>[Transformed/Newly Created]</status>
                <changes>
        - [Change 1]
        - [Change 2]
        - ...
                </changes>
            </file_summary>

        Repeat the file_summary section for each file processed.

        After processing all files, provide a final summary of the transformation process:

            <transformation_summary>
        Total files processed: [Number]
        Files transformed: [Number]
        New files created: [Number]
        Key observations or challenges:
        - [Observation 1]
        - [Observation 2]
        - ...
            </transformation_summary>

        Remember to maintain consistency in your approach across all cloud providers and ensure that the transformed files align with the existing examples in the transformed repository.
        </instruction>
        <instruction>
        Double check your work, and make sure that the code would compile if go build was ran, if not correct the file or add a comment where the change is needed, and add that to the problem to the file_summary
        </instruction>
    </instructions>
    <examples>
        <example>
            <before>
                <![CDATA[
            package aws

            import (
                "fmt"

                "github.com/infracost/infracost/internal/resources/aws"
                "github.com/infracost/infracost/internal/schema"

                "github.com/tidwall/gjson"
            )

            func getInstanceRegistryItem() *schema.RegistryItem {
                return &schema.RegistryItem{
                    Name: "aws_instance",
                    Notes: []string{
                        "Costs associated with marketplace AMIs are not supported.",
                        "For non-standard Linux AMIs such as Windows and RHEL, the operating system should be specified in usage file.",
                        "EC2 detailed monitoring assumes the standard 7 metrics and the lowest tier of prices for CloudWatch.",
                        "If a root volume is not specified then an 8Gi gp2 volume is assumed.",
                    },
                    CoreRFunc: NewInstance,
                    ReferenceAttributes: []string{
                        "ebs_block_device.#.volume_id",
                        "host_id",
                        "launch_template.#.id",
                        "launch_template.#.name",
                    },
                }
            }

            func NewInstance(d *schema.ResourceData) schema.CoreResource {
                region := d.Get("region").String()

                purchaseOption := "on_demand"
                if d.Get("spot_price").String() != "" {
                    purchaseOption = "spot"
                }

                var instanceType, ami, cpuCredits, tenancy string
                var ebsOptimized, monitoring bool
                ltEBSBlockDevices := map[string]*aws.EBSVolume{}

                launchTemplateRefs := d.References("launch_template.#.id")
                if len(launchTemplateRefs) == 0 {
                    launchTemplateRefs = d.References("launch_template.#.name")
                }

                if len(launchTemplateRefs) > 0 {
                    ref := launchTemplateRefs[0]

                    instanceType = ref.Get("instance_type").String()
                    ami = ref.Get("image_id").String()
                    ebsOptimized = ref.Get("ebs_optimized").Bool()
                    monitoring = ref.Get("monitoring.0.enabled").Bool()
                    cpuCredits = ref.Get("credit_specification.0.cpu_credits").String()
                    tenancy = ref.Get("placement.0.tenancy").String()

                    for _, data := range ref.Get("block_device_mappings").Array() {
                        deviceName := data.Get("device_name").String()
                        ebsBlockDevice := &aws.EBSVolume{
                            Region: region,
                            Type:   data.Get("ebs.0.volume_type").String(),
                            IOPS:   data.Get("ebs.0.iops").Int(),
                        }

                        if v := data.Get("ebs.0.volume_size"); v.Exists() {
                            ebsBlockDevice.Size = intPtr(v.Int())
                        }

                        ltEBSBlockDevices[deviceName] = ebsBlockDevice
                    }
                }

                instanceType = d.GetStringOrDefault("instance_type", instanceType)
                ami = d.GetStringOrDefault("ami", ami)
                ebsOptimized = d.GetBoolOrDefault("ebs_optimized", ebsOptimized)
                monitoring = d.GetBoolOrDefault("monitoring", monitoring)
                cpuCredits = d.GetStringOrDefault("credit_specification.0.cpu_credits", cpuCredits)
                tenancy = d.GetStringOrDefault("tenancy", tenancy)
                hasHost := len(d.References("host_id")) > 0

                a := &aws.Instance{
                    Address:          d.Address,
                    Region:           region,
                    Tenancy:          tenancy,
                    PurchaseOption:   purchaseOption,
                    AMI:              ami,
                    InstanceType:     instanceType,
                    EBSOptimized:     ebsOptimized,
                    EnableMonitoring: monitoring,
                    CPUCredits:       cpuCredits,
                    HasHost:          hasHost,
                }

                a.RootBlockDevice = &aws.EBSVolume{
                    Address: "root_block_device",
                    Region:  region,
                    Type:    d.Get("root_block_device.0.volume_type").String(),
                    IOPS:    d.Get("root_block_device.0.iops").Int(),
                }

                if d.Get("root_block_device.0.volume_size").Type != gjson.Null {
                    a.RootBlockDevice.Size = intPtr(d.Get("root_block_device.0.volume_size").Int())
                }

                ebsBlockDeviceRef := d.References("ebs_block_device.#.volume_id")

                for i, data := range d.Get("ebs_block_device").Array() {
                    deviceName := data.Get("device_name").String()

                    ltDevice := ltEBSBlockDevices[deviceName]
                    if ltDevice == nil {
                        ltDevice = &aws.EBSVolume{}
                    }

                    // Check if there's a reference for this EBS volume
                    // If there is then we shouldn't add as a subresource since
                    // the cost will be added against the volume resource.
                    if len(ebsBlockDeviceRef) > i && ebsBlockDeviceRef[i].Get("id").String() == data.Get("volume_id").String() {
                        delete(ltEBSBlockDevices, deviceName)

                        continue
                    }

                    // Instance can override individual Launch Template's values based on device
                    // name.
                    volumeType := ltDevice.Type
                    if v := data.Get("volume_type"); v.Exists() {
                        volumeType = v.String()
                    }

                    volumeSize := ltDevice.Size
                    if v := data.Get("volume_size"); v.Exists() {
                        volumeSize = intPtr(v.Int())
                    }

                    iops := ltDevice.IOPS
                    if v := data.Get("iops"); v.Exists() {
                        iops = v.Int()
                    }

                    ebsBlockDevice := &aws.EBSVolume{
                        Address: fmt.Sprintf("ebs_block_device[%d]", i),
                        Region:  region,
                        Type:    volumeType,
                        Size:    volumeSize,
                        IOPS:    iops,
                    }

                    delete(ltEBSBlockDevices, deviceName)

                    a.EBSBlockDevices = append(a.EBSBlockDevices, ebsBlockDevice)
                }

                // Add remaining EBS block devices from Launch Template.
                blockDevicesCount := len(a.EBSBlockDevices)
                for _, device := range ltEBSBlockDevices {
                    device.Address = fmt.Sprintf("ebs_block_device[%d]", blockDevicesCount)
                    a.EBSBlockDevices = append(a.EBSBlockDevices, device)
                    blockDevicesCount++
                }

                return a
            }
            ]]>
            </before>
            <after>
                <![CDATA[
            package aws

            import (
                "fmt"

                "github.com/infracost/infracost/internal/resources/aws"
                "github.com/infracost/infracost/internal/schema"
                log "github.com/sirupsen/logrus"
                "github.com/tidwall/gjson"
            )

            func getInstanceRegistryItem() *schema.RegistryItem {
                return &schema.RegistryItem{
                    //Name: "aws:ec2/instance:Instance",
                    Name: "aws_ec2_instance",
                    Notes: []string{
                        "Costs associated with marketplace AMIs are not supported.",
                        "For non-standard Linux AMIs such as Windows and RHEL, the operating system should be specified in usage file.",
                        "EC2 detailed monitoring assumes the standard 7 metrics and the lowest tier of prices for CloudWatch.",
                        "If a root volume is not specified then an 8Gi gp2 volume is assumed.",
                    },
                    RFunc: NewInstance,
                    ReferenceAttributes: []string{
                        "ebsBlockDevices.#.volumeId",
                        "launchTemplate.#.id",
                        "launchTemplate.#.name",
                    },
                }
            }

            func NewInstance(d *schema.ResourceData, u *schema.UsageData) *schema.Resource {

                purchaseOption := "on_demand"
                if d.Get("spot_price").String() != "" {
                    purchaseOption = "spot"
                }

                var instanceType, ami, cpuCredits, tenancy string
                var ebsOptimized, monitoring bool
                ltEBSBlockDevices := map[string]*aws.EBSVolume{}

                launchTemplateRefs := d.References("launchTemplate.#.id")
                if len(launchTemplateRefs) == 0 {
                    launchTemplateRefs = d.References("launchTemplate.#.name")
                }

                if len(launchTemplateRefs) > 0 {
                    ref := launchTemplateRefs[0]

                    instanceType = ref.Get("instanceType").String()
                    ami = ref.Get("image_id").String()
                    ebsOptimized = ref.Get("ebs_optimized").Bool()
                    monitoring = ref.Get("monitoring.0.enabled").Bool()
                    cpuCredits = ref.Get("credit_specification.0.cpu_credits").String()
                    tenancy = ref.Get("placement.0.tenancy").String()

                    for _, data := range ref.Get("ebsBlockDevices").Array() {
                        deviceName := data.Get("deviceName").String()
                        ebsBlockDevice := &aws.EBSVolume{
                            Region: data.Get("region").String(),
                            Type:   data.Get("ebs.0.volume_type").String(),
                            IOPS:   data.Get("ebs.0.iops").Int(),
                        }

                        if v := data.Get("ebs.0.volume_size"); v.Exists() {
                            ebsBlockDevice.Size = intPtr(v.Int())
                        }

                        ltEBSBlockDevices[deviceName] = ebsBlockDevice
                    }
                }

                instanceType = d.GetStringOrDefault("instanceType", instanceType)
                ami = d.GetStringOrDefault("ami", ami)
                ebsOptimized = d.GetBoolOrDefault("ebsOptimized", ebsOptimized)
                monitoring = d.GetBoolOrDefault("monitoring", monitoring)
                cpuCredits = d.GetStringOrDefault("creditSpecification.cpuCredits", cpuCredits)
                tenancy = d.GetStringOrDefault("tenancy", tenancy)

                a := &aws.Instance{
                    Address:          d.Address,
                    Region:           d.Get("region").String(),
                    Tenancy:          tenancy,
                    PurchaseOption:   purchaseOption,
                    AMI:              ami,
                    InstanceType:     instanceType,
                    EBSOptimized:     ebsOptimized,
                    EnableMonitoring: monitoring,
                    CPUCredits:       cpuCredits,
                }

                a.RootBlockDevice = &aws.EBSVolume{
                    Address: "root_block_device",
                    Region:  d.Get("region").String(),
                    Type:    d.Get("rootBlockDevice.volumeType").String(),
                    IOPS:    d.Get("rootBlockDevice.iops").Int(),
                }

                if d.Get("rootBlockDevice.volumeSize").Type != gjson.Null {
                    a.RootBlockDevice.Size = intPtr(d.Get("rootBlockDevice.volumeSize").Int())
                }
                // Parsing Block Device References
                // the # is a gjson directive meaning that its entering an array.
                ebsBlockDeviceRef := d.References("ebsBlockDevices.#.volumeId")

                for i, data := range d.Get("ebsBlockDevices").Array() {
                    deviceName := data.Get("deviceName").String()
                    volString := fmt.Sprintf(`propertyDependencies.ebsBlockDevices.%d`, i)
                    deviceInPropertyDependencies := d.RawValues.Get(volString)
                    // log.Debugf("volString: %s, dIPD %s", volString, deviceInPropertyDependencies)
                    ltDevice := ltEBSBlockDevices[deviceName]
                    if ltDevice == nil {
                        ltDevice = &aws.EBSVolume{}
                    }

                    // Check if there's a reference for this EBS volume
                    // If there is then we shouldn't add as a subresource since
                    // the cost will be added against the volume resource.

                    if len(ebsBlockDeviceRef) > i && ebsBlockDeviceRef[i].RawValues.Get("urn").String() == deviceInPropertyDependencies.String() {
                        log.Debugf("Found in block divide ref, deleting")
                        delete(ltEBSBlockDevices, deviceName)

                        continue
                    }

                    // Instance can override individual Launch Template's values based on device
                    // name.
                    volumeType := ltDevice.Type
                    if v := data.Get("volumeType"); v.Exists() {
                        volumeType = v.String()
                    }

                    volumeSize := ltDevice.Size
                    if v := data.Get("volumeSize"); v.Exists() {
                        volumeSize = intPtr(v.Int())
                    }

                    iops := ltDevice.IOPS
                    if v := data.Get("iops"); v.Exists() {
                        iops = v.Int()
                    }

                    ebsBlockDevice := &aws.EBSVolume{
                        Address: fmt.Sprintf("ebs_block_device[%d]", i),
                        Region:  d.Get("region").String(),
                        Type:    volumeType,
                        Size:    volumeSize,
                        IOPS:    iops,
                    }

                    delete(ltEBSBlockDevices, deviceName)

                    a.EBSBlockDevices = append(a.EBSBlockDevices, ebsBlockDevice)
                }

                // Add remaining EBS block devices from Launch Template.
                blockDevicesCount := len(a.EBSBlockDevices)
                for _, device := range ltEBSBlockDevices {
                    device.Address = fmt.Sprintf("ebs_block_device[%d]", blockDevicesCount)
                    a.EBSBlockDevices = append(a.EBSBlockDevices, device)
                    blockDevicesCount++
                }

                a.PopulateUsage(u)

                return a.BuildResource()

            }
            ]]>
            </after>
        </example>
    </examples>
</conventions>