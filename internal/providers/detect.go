package providers

import (
	"archive/zip"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"sync"

	"github.com/awslabs/goformation/v4"

	"github.com/infracost/infracost/internal/config"
	"github.com/infracost/infracost/internal/hcl"
	"github.com/infracost/infracost/internal/logging"
	"github.com/infracost/infracost/internal/providers/cloudformation"
	"github.com/infracost/infracost/internal/providers/terraform"
	"github.com/infracost/infracost/internal/schema"
)

// Detect returns a list of providers for the given path. Multiple returned
// providers are because of auto-detected root modules residing under the
// original path.
func Detect(ctx *config.RunContext, project *config.Project, includePastResources bool) ([]schema.Provider, error) {
	path := project.Path

	if _, err := os.Stat(path); os.IsNotExist(err) {
		return nil, fmt.Errorf("No such file or directory %s", path)
	}

	forceCLI := project.TerraformForceCLI
	projectType := DetectProjectType(path, forceCLI)
	projectContext := config.NewProjectContext(ctx, project, nil)
	if projectType != ProjectTypeAutodetect {
		projectContext.ContextValues.SetValue("project_type", projectType)
	}

	switch projectType {
	case ProjectTypeTerraformPlanJSON:
		return []schema.Provider{terraform.NewPlanJSONProvider(projectContext, includePastResources)}, nil
	case ProjectTypeTerraformPlanBinary:
		return []schema.Provider{terraform.NewPlanProvider(projectContext, includePastResources)}, nil
	case ProjectTypeTerraformCLI:
		return []schema.Provider{terraform.NewDirProvider(projectContext, includePastResources)}, nil
	case ProjectTypeTerragruntCLI:
		return []schema.Provider{terraform.NewTerragruntProvider(projectContext, includePastResources)}, nil
	case ProjectTypeTerraformStateJSON:
		return []schema.Provider{terraform.NewStateJSONProvider(projectContext, includePastResources)}, nil
	case ProjectTypeCloudFormation:
		return []schema.Provider{cloudformation.NewTemplateProvider(projectContext, includePastResources)}, nil
	case ProjectTypeTerragruntDir:
		h := terraform.NewTerragruntHCLProvider(projectContext, includePastResources)

		return []schema.Provider{h}, nil
	}

	locatorConfig := &hcl.ProjectLocatorConfig{
		ExcludedDirs:   append(project.ExcludePaths, ctx.Config.Autodetect.ExcludeDirs...),
		IncludedDirs:   ctx.Config.Autodetect.IncludeDirs,
		EnvNames:       ctx.Config.Autodetect.EnvNames,
		ChangedObjects: ctx.VCSMetadata.Commit.ChangedObjects,
		UseAllPaths:    project.IncludeAllPaths,
	}
	pl := hcl.NewProjectLocator(logging.Logger, locatorConfig)
	rootPaths := pl.FindRootModules(project.Path)
	if len(rootPaths) == 0 {
		return nil, fmt.Errorf("could not detect path type for '%s'", path)
	}

	var autoProviders []schema.Provider
	for _, rootPath := range rootPaths {
		projectContext := config.NewProjectContext(ctx, project, nil)

		options := []hcl.Option{hcl.OptionWithSpinner(ctx.NewSpinner)}
		projectContext.ContextValues.SetValue("project_type", "terraform_dir")
		if ctx.Config.ConfigFilePath == "" && len(project.TerraformVarFiles) == 0 {
			autoProviders = append(autoProviders, autodetectedRootToProviders(pl, projectContext, rootPath, options...)...)
		} else {
			autoProviders = append(autoProviders, configFileRootToProvider(rootPath, options, projectContext, pl))
		}

	}

	return autoProviders, nil
}

// configFileRootToProvider returns a provider for the given root path which is
// assumed to be a root module defined with a config file. In this case the
// terraform var files should not be grouped/reordered as the user has specified
// these manually.
func configFileRootToProvider(rootPath hcl.RootPath, options []hcl.Option, projectContext *config.ProjectContext, pl *hcl.ProjectLocator) *terraform.HCLProvider {
	var autoVarFiles []string
	for _, varFile := range rootPath.TerraformVarFiles {
		if hcl.IsAutoVarFile(varFile) && (filepath.Dir(varFile) == rootPath.Path || filepath.Dir(varFile) == ".") {
			autoVarFiles = append(autoVarFiles, varFile)
		}
	}

	if len(autoVarFiles) > 0 {
		options = append(options, hcl.OptionWithTFVarsPaths(autoVarFiles, false))
	}

	h, providerErr := terraform.NewHCLProvider(
		projectContext,
		rootPath,
		pl,
		nil,
		options...,
	)
	if providerErr != nil {
		logging.Logger.Warn().Err(providerErr).Msgf("could not initialize provider for path %q", rootPath.Path)
	}
	return h
}

// autodetectedRootToProviders returns a list of providers for the given root
// path. These providers are generated by autodetected environments defined in
// the root module. These are defined by var file naming conventions.
func autodetectedRootToProviders(pl *hcl.ProjectLocator, projectContext *config.ProjectContext, rootPath hcl.RootPath, options ...hcl.Option) []schema.Provider {
	var providers []schema.Provider
	var varFiles []string
	var autoVarFiles []string

	// first remove all the "auto" tfvar files from the list of discovered var files.
	// These files should not constitute a new "project" as they won't define an
	// environment but defaults that should be applied across all environments.
	for _, varFile := range rootPath.TerraformVarFiles {
		if hcl.IsAutoVarFile(varFile) {
			autoVarFiles = append(autoVarFiles, varFile)
			continue
		}

		if pl.IsGlobalVarFile(varFile) {
			autoVarFiles = append(autoVarFiles, varFile)
			continue
		}

		varFiles = append(varFiles, varFile)
	}

	// group the var files by environment. This is done by taking the base name of
	// the var file. This is done to deduplicate var files that are for the same
	// environment but have different file paths.
	varFileGrouping := map[string][]string{}
	for _, varFile := range varFiles {
		if !hcl.VarFileEnvPrefixRegxp.MatchString(hcl.CleanVarName(varFile)) {
			env := hcl.CleanVarName(varFile)
			varFileGrouping[env] = append(varFileGrouping[env], varFile)
		}
	}

	// loop through the var files again and if there are any global var files
	// with a defaults prefix, add them to the grouping for each environment
	// only if the environment exists.
	for _, varFile := range varFiles {
		if hcl.VarFileEnvPrefixRegxp.MatchString(hcl.CleanVarName(varFile)) {
			env := hcl.VarEnvName(varFile)

			if _, ok := varFileGrouping[env]; ok {
				varFileGrouping[env] = append(varFileGrouping[env], varFile)
			}
		}
	}

	var varEnvs []string
	for env := range varFileGrouping {
		varEnvs = append(varEnvs, env)
	}
	sort.Strings(varEnvs)

	if len(varFileGrouping) > 0 {
		sort.Strings(rootPath.TerraformVarFiles)

		for _, env := range varEnvs {
			provider, err := terraform.NewHCLProvider(
				projectContext,
				rootPath,
				pl,
				nil,
				append(
					options,
					hcl.OptionWithTFVarsPaths(append(autoVarFiles, varFileGrouping[env]...), true),
					hcl.OptionWithModuleSuffix(env),
				)...)
			if err != nil {
				logging.Logger.Warn().Err(err).Msgf("could not initialize provider for path %q", rootPath.Path)
				continue
			}

			providers = append(providers, provider)
		}

		return providers
	}

	providerOptions := options
	if len(autoVarFiles) > 0 {
		providerOptions = append(providerOptions, hcl.OptionWithTFVarsPaths(append(varFiles, autoVarFiles...), true))
	}

	provider, err := terraform.NewHCLProvider(
		projectContext,
		rootPath,
		pl,
		nil,
		providerOptions...,
	)
	if err != nil {
		logging.Logger.Warn().Err(err).Msgf("could not initialize provider for path %q", rootPath.Path)
		return nil
	}

	return []schema.Provider{provider}
}

type ProjectType string

var (
	ProjectTypeTerraformPlanJSON   ProjectType = "terraform_plan_json"
	ProjectTypeTerraformPlanBinary ProjectType = "terraform_plan_binary"
	ProjectTypeTerraformCLI        ProjectType = "terraform_cli"
	ProjectTypeTerragruntCLI       ProjectType = "terragrunt_cli"
	ProjectTypeTerraformStateJSON  ProjectType = "terraform_state_json"
	ProjectTypeCloudFormation      ProjectType = "cloudformation"
	ProjectTypeTerragruntDir       ProjectType = "terragrunt_dir"
	ProjectTypeAutodetect          ProjectType = "autodetect"
)

func DetectProjectType(path string, forceCLI bool) ProjectType {
	if isCloudFormationTemplate(path) {
		return ProjectTypeCloudFormation
	}

	if isTerraformPlanJSON(path) {
		return ProjectTypeTerraformPlanJSON
	}

	if isTerraformStateJSON(path) {
		return ProjectTypeTerraformStateJSON
	}

	if isTerraformPlan(path) {
		return ProjectTypeTerraformPlanBinary
	}

	if isTerragruntNestedDir(path, 5) {
		if forceCLI {
			return ProjectTypeTerragruntCLI
		}

		return ProjectTypeTerragruntDir
	}

	if forceCLI {
		return ProjectTypeTerraformCLI
	}

	return ProjectTypeAutodetect
}

func isTerraformPlanJSON(path string) bool {
	b, err := os.ReadFile(path)
	if err != nil {
		return false
	}

	var jsonFormat struct {
		FormatVersion string      `json:"format_version"`
		PlannedValues interface{} `json:"planned_values"`
	}

	b, hasWrapper := terraform.StripSetupTerraformWrapper(b)
	if hasWrapper {
		logging.Logger.Info().Msgf("Stripped wrapper output from %s (to make it a valid JSON file) since setup-terraform GitHub Action was used without terraform_wrapper: false", path)
	}

	err = json.Unmarshal(b, &jsonFormat)
	if err != nil {
		return false
	}

	return jsonFormat.FormatVersion != "" && jsonFormat.PlannedValues != nil
}

func isTerraformStateJSON(path string) bool {
	b, err := os.ReadFile(path)
	if err != nil {
		return false
	}

	var jsonFormat struct {
		FormatVersion string      `json:"format_version"`
		Values        interface{} `json:"values"`
	}

	b, hasWrapper := terraform.StripSetupTerraformWrapper(b)
	if hasWrapper {
		logging.Logger.Debug().Msgf("Stripped setup-terraform wrapper output from %s", path)
	}

	err = json.Unmarshal(b, &jsonFormat)
	if err != nil {
		return false
	}

	return jsonFormat.FormatVersion != "" && jsonFormat.Values != nil
}

func isTerraformPlan(path string) bool {
	r, err := zip.OpenReader(path)
	if err != nil {
		return false
	}
	defer r.Close()

	var planFile *zip.File
	for _, file := range r.File {
		if file.Name == "tfplan" {
			planFile = file
			break
		}
	}

	return planFile != nil
}

func isTerragruntDir(path string) bool {
	if val, ok := os.LookupEnv("TERRAGRUNT_CONFIG"); ok {
		if filepath.IsAbs(val) {
			return config.FileExists(val)
		}
		return config.FileExists(filepath.Join(path, val))
	}

	return config.FileExists(filepath.Join(path, "terragrunt.hcl")) || config.FileExists(filepath.Join(path, "terragrunt.hcl.json"))
}

func isTerragruntNestedDir(path string, maxDepth int) bool {
	if isTerragruntDir(path) {
		return true
	}

	if maxDepth > 0 {
		entries, err := os.ReadDir(path)
		if err == nil {
			for _, entry := range entries {
				name := entry.Name()
				if entry.IsDir() && name != config.InfracostDir && name != ".terraform" {
					if isTerragruntNestedDir(filepath.Join(path, name), maxDepth-1) {
						return true
					}
				}
			}
		}
	}
	return false
}

// goformation lib is not threadsafe, so we run this check synchronously
// See: https://github.com/awslabs/goformation/issues/363
var cfMux = &sync.Mutex{}

func isCloudFormationTemplate(path string) bool {
	cfMux.Lock()
	defer cfMux.Unlock()

	template, err := goformation.Open(path)
	if err != nil {
		return false
	}

	if len(template.Resources) > 0 {
		return true
	}

	return false
}
